# -*- coding: utf-8 -*-
"""ASSIGNMENT_3_Question1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vjsv6y0Fxd9uAr468zJxGPINNQz0zGnY
"""

from queue import PriorityQueue
import time

class Node:
    def __init__(self, state, parent=None, action=None, path_cost=0):
        self.state = state
        self.parent = parent
        self.action = action
        self.path_cost = path_cost
        self.children = []

    def find_blank(self):
        for i in range(len(self.state)):
            for j in range(len(self.state[i])):
                if self.state[i][j] == 0:
                    return i, j

    def get_possible_moves(self):
        possible_moves = []
        i, j = self.find_blank()
        if i > 0: possible_moves.append((i-1, j))
        if i < 2: possible_moves.append((i+1, j))
        if j > 0: possible_moves.append((i, j-1))
        if j < 2: possible_moves.append((i, j+1))
        return possible_moves

    def generate_child(self, move):
        i, j = self.find_blank()
        new_state = [row.copy() for row in self.state]
        new_state[i][j], new_state[move[0]][move[1]] = new_state[move[0]][move[1]], new_state[i][j]
        return Node(new_state, self, move, self.path_cost+1)

    def __eq__(self, other):
        return self.state == other.state

    def __lt__(self, other):
        return True

def h2(state, goal):
    displaced = 0
    for i in range(len(state)):
        for j in range(len(state[i])):
            if state[i][j] != 0 and state[i][j] != goal[i][j]:
                displaced += 1
    return displaced

def h3(state, goal):
    manhattan_distance = 0
    for i in range(len(state)):
        for j in range(len(state[i])):
            if state[i][j] != 0:
                goal_i, goal_j = find_position(goal, state[i][j])
                manhattan_distance += abs(i - goal_i) + abs(j - goal_j)
    return manhattan_distance

def h4(state, goal):
    return max(h2(state, goal), h3(state, goal)) + 1

def find_position(matrix, value):
    for i in range(len(matrix)):
        for j in range(len(matrix[i])):
            if matrix[i][j] == value:
                return (i, j)

def a_star_search(initial, goal, heuristic):
    explored = set()
    start_node = Node(initial)
    frontier = PriorityQueue()
    frontier.put((heuristic(initial, goal), start_node))
    while not frontier.empty():
        _, current = frontier.get()
        explored.add(tuple(map(tuple, current.state)))
        if current.state == goal:
            return current
        for move in current.get_possible_moves():
            child = current.generate_child(move)
            if tuple(map(tuple, child.state)) not in explored:
                f = child.path_cost + heuristic(child.state, goal)
                frontier.put((f, child))
    return None

def print_solution(node):
    path = []
    while node:
        path.append(node.state)
        node = node.parent
    path.reverse()
    for state in path:
        for row in state:
            print(row)
        print()

initial = [
    [1, 2, 3],
    [5, 0, 6],
    [7, 8, 4]
]
goal = [
    [1, 2, 3],
    [5, 8, 6],
    [0, 7, 4]
]

start_time = time.time()
result = a_star_search(initial, goal, h3)  # Using h3 as an example.
end_time = time.time()

if result:
    print_solution(result)
else:
    print("No solution found!")

print(f"Execution time: {end_time - start_time:.4f} seconds")